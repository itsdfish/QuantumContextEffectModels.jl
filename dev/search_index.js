var documenterSearchIndex = {"docs":
[{"location":"developing_a_model/#Developing-a-Context-Effect-Model","page":"Developing a Model","title":"Developing a Context Effect Model","text":"","category":"section"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"In this example, we illustrate the process of creating a new model of context effects using the model developed in Busemeyer & Wang (2018). This model is included with the package and is used throughout the documentation to illustrate how to use the API. ","category":"page"},{"location":"developing_a_model/#Model-Overview","page":"Developing a Model","title":"Model Overview","text":"","category":"section"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"The model was developed by Busemeyer & Wang (2018) to explain context effects in judgments of public service announcement (PSA) posters. Subjects made binary (yes,no) judgments along the following four attributes:","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"Believable\nInformative\nPersuasive\nLikable ","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"Subjects judged pairs of attributes rather than all four attributes simultanouesly. In total, there were P(42) = 12 permutations (e.g., [B,I],[I,B],[B,P], ...). Each pair forms a 2 times 2 table. A context effect is observed if the twelve 2 times 2 tables cannot be deduced from a single joint probability distribution across the four attributes. ","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"A quamtum model for compatible events represents beliefs in an attribute space with 2^4 = 16 dimensions. This type of model does not produce context effects, and is formally equivalent to a classical probability model. However, when events are incompatible, their joint distribution is not defined. Instead, attributes are represented in a lower dimensional space in which different bases are used to describe incompatible events. Specifically, the basis for incompatible pairs are found by rotating the basis for compatible pairs. The following pairs are incompatible ","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"Believable and Perusaive\nInformative and Likable","category":"page"},{"location":"developing_a_model/#Create-Model-Subtype","page":"Developing a Model","title":"Create Model Subtype","text":"","category":"section"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"The first step in developing a new model is to create a new subtype of AbstractQuantumModel. Any subtype of AbstractQuantumModel will be compatible with default internal functions used to compute predictions, simulate data, and evaluate the loglikelihood of data with respect to the model. ","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"The model object below contains six parameters: ","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"Psi: a 4 times 1 initial state vector consisting of four parameters\ntheta_li in -11: a rotation parameter to rotate the \ntheta_pb in -11: a rotation parameter to rotate the ","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"mutable struct QuantumModel{T<:Real} <: AbstractQuantumModel\n    Ψ::Vector{T}\n    θli::T \n    θpb::T \nend","category":"page"},{"location":"developing_a_model/#Create-Projector-Generator","page":"Developing a Model","title":"Create Projector Generator","text":"","category":"section"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"The other step is to extend the function make_projectors, which, as its name implies, creates projectors. There are two basic steps for creating the projectors. First, we create projectors for responding yes to each of the binary attributes. For example, Pb = My ⊗ I(2) projects the superposition state onto the subspace corresponding to believable. Second, all possible projectors are enumerated and organized into a vector of vectors, where the subvectors correspond to all possible responses to a given attribute. In the case of binary attributes, each subvector is of length 2 and responding no is the complement of responding yes: mathbfP_n = I - mathbfP_y. The vector of projectors is organized accordingly:","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"mathbfP_bymathbfP_bnmathbfP_iymathbfP_inmathbfP_pymathbfP_pnmathbfP_lymathbfP_ln","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"where subscripts b, i, p and l correspond to attributes believable, informative, persuasive and likable, respectively. Note that the package can accomodate projectors an arbitrary number of dimensions, including attributes with different number of response outcomes.","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"function make_projectors(model::QuantumModel)\n    (;θli, θpb) = model\n\n    # 2D projector for responding \"yes\"\n    My = [1 0; 0 0]\n    # unitary transformation matrices\n    Upb = U(θpb)\n    Uli = U(θli)\n\n    # projector for responding \"yes\" to believable\n    Pb = My ⊗ I(2)\n    # projector for responding \"yes\" to informative\n    Pi = I(2) ⊗ My\n    # projector for responding \"yes\" to persuasive    \n    Pp = (Upb * My * Upb') ⊗ I(2)\n    # projector for responding \"yes\" to likable    \n    Pl = I(2) ⊗ (Uli * My * Uli')\n\n    projectors = [\n        [Pb,I(4)-Pb],\n        [Pi,I(4)-Pi],\n        [Pp,I(4)-Pp],\n        [Pl,I(4)-Pl],\n    ]\n    return projectors\nend","category":"page"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"After defining the model subtype and make_projectors, the model will work with the package API. ","category":"page"},{"location":"developing_a_model/#References","page":"Developing a Model","title":"References","text":"","category":"section"},{"location":"developing_a_model/","page":"Developing a Model","title":"Developing a Model","text":"Busemeyer, J. R., & Wang, Z. (2018). Hilbert space multidimensional theory. Psychological Review, 125(4), 572.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumContextEffectModels]\nOrder   = [:type, :function]\nPrivate = false","category":"page"},{"location":"api/#QuantumContextEffectModels.QuantumModel","page":"API","title":"QuantumContextEffectModels.QuantumModel","text":"QuantumModel{T<:Real} <: AbstractQuantumModel\n\nFields\n\nΨ::Vector{T}: initial state vector \nθli::T: parameter for rotating basis from likable to informative. θli ∈ [-1,1]\nθpb::T:  parameter for rotating basis from persuasive to believable. θli ∈ [-1,1]\n\nConstructors\n\nQuantumModel( Ψ, θli, θpb)\n\nQuantumModel(; Ψ, θli, θpb)\n\nReference\n\nBusemeyer, J. R., & Wang, Z. (2018). Hilbert space multidimensional theory. Psychological Review, 125(4), 572.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.rand-Tuple{AbstractQuantumModel, Int64}","page":"API","title":"Base.rand","text":"rand(\n    dist::AbstractQuantumModel,\n    n_trials::Int;\n    joint_func = get_ordered_joint_probs,\n    n_way\n)\n\nSimulates n_trials of judgements per condition for all possible ordered collections of size n_way.\n\nArguments\n\ndist::AbstractQuantumModel:an abstract quantum model object\nn_trials::Int: number of trials per condition \n\nKeywords\n\njoint_func = get_ordered_joint_probs: joint probability function. The function get_ordered_joint_probs returns \n\nall possible orders where as the function get_joint_probs returns joint probabilities in the order specified in  make_projectors.\n\nn_way: the number of attributes simultaneously judged, forming an n_way-table. \n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{AbstractQuantumModel, Vector{Vector{Int64}}, Int64}","page":"API","title":"Distributions.logpdf","text":"logpdf(\n    dist::AbstractQuantumModel,\n    data::Vector{Vector{Int}},\n    n_trials::Int;\n    n_way\n)\n\nEvaluates log likelihood of all judgements for all possible sets of size n_way.\n\nArguments\n\ndist::AbstractQuantumModel:an abstract quantum model object\ndata::Vector{Vector{Int}}: frequencies of yes responses for all n_way tables (excluding order)\nn_trials::Int: number of trials per condition \n\nKeywords\n\nn_way: the number of attributes simultaneously judged, forming an n_way-table. \n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{AbstractQuantumModel, Vector{Vector{Vector{Int64}}}, Int64}","page":"API","title":"Distributions.logpdf","text":"logpdf(\n    dist::AbstractQuantumModel,\n    data::Vector{Vector{Vector{Int}}},\n    n_trials::Int;\n    n_way\n)\n\nEvaluates the log likelihood of all judgements per condition for all possible ordered collections of size n_way.\n\nArguments\n\ndist::AbstractQuantumModel:an abstract quantum model object\ndata::Vector{Vector{Vector{Int}}}: frequencies of yes responses for all n_way tables and orders\nn_trials::Int: number of trials per condition \n\nKeywords\n\nn_way: the number of attributes simultaneously judged, forming an n_way-table. \n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.get_joint_probs-Tuple{AbstractQuantumModel, Any, Any}","page":"API","title":"QuantumContextEffectModels.get_joint_probs","text":"get_joint_probs(model::AbstractQuantumModel, projectors, Ψ)\n\nComputes joint probabilities for a distribution with an arbitrary number of dimensions and values per dimension. The total number of elements is n = Πᵢᵐ nᵢ, where nᵢ is the number of possible values for the ith dimension. For example, the joint probabilties for two binary variables is organized as follows:\n\nyes yes\nyes no\nno yes\nno no\n\nArguments\n\nmodel::AbstractQuantumModel:an abstract quantum model object\nprojectors: a vector of projectors\nΨ: superposition state vector \n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.get_ordered_joint_probs-Union{Tuple{T}, Tuple{AbstractQuantumModel{T}, Any, Any}} where T","page":"API","title":"QuantumContextEffectModels.get_ordered_joint_probs","text":"get_ordered_joint_probs(model::AbstractQuantumModel, projectors, Ψ)\n\nComputes joint probabilities for all posible orders. The function works for a distribution with an arbitrary number of dimensions and values per dimension. The total number of elements is n = Πᵢᵐ nᵢ, where nᵢ is the number of possible values for the ith dimension. \n\nArguments\n\nmodel::AbstractQuantumModel:an abstract quantum model object\nprojectors: a vector of projectors\nΨ: superposition state vector \n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.make_projectors-Tuple{QuantumModel}","page":"API","title":"QuantumContextEffectModels.make_projectors","text":"make_projectors(model::QuantumModel)\n\nReturns projectors for each value of each variable. \n\nArguments\n\nmodel::AbstractQuantumModel:an abstract quantum model object\n\nReturns\n\nprojectors::Vector{Vector{Float64}}: a nested vector of projectors \n\nFor this model, there are four variables (believable,infromative,persuasive,likable) with binary values (yes, no). The projectors organized as follows [[Pby Pbn],[Piy Pin],[Ppy Ppn],[Ply Pln]], where the first index corresponds to the variable and the second index correspons to the binary value. For example, Pbn, is the projector for responding \"no\" to the question about believable. \n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.predict-Tuple{AbstractQuantumModel}","page":"API","title":"QuantumContextEffectModels.predict","text":"predict(\n    model::AbstractQuantumModel; \n    n_way, \n    joint_func = get_ordered_joint_probs\n)\n\nComputes response probabilities all possible n_way joint probability tables. If get_ordered_joint_probs is assigned to joint_func, all orders within each n_way table is included. If get_joint_probs is assigned to joint_func, the output will include only one order perh n_way joint probability table. The order used is based  on the projectors defined in make_projectors.\n\nArguments\n\nmodel::AbstractQuantumModel:an abstract quantum model object\n\nKeywords\n\nn_way: the number of attributes judged simultaneously to form an n-way joint probability table \njoint_func=get_ordered_joint_probs: joint probability function. The function get_ordered_joint_probs returns \n\nall possible orders where as the function get_joint_probs returns joint probabilities in the order specified in  make_projectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.to_dataframe-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{Array{Array{Vector{T}, 1}, 1}, T1, T2, Int64}} where {T, T1<:(Vector), T2<:(Vector)}","page":"API","title":"QuantumContextEffectModels.to_dataframe","text":"to_dataframe(\n    data::Vector{Vector{Vector{Float64}}},\n    attributes::T1,\n    values::T2,\n    n_way::Int\n)\n\nArguments\n\ndata::Vector{Vector{Vector{T}}}: a three-level nested data vector of vectors representing data or predictions. The first level contains different subsets of    n_way joint probabilities (e.g., {B,I},{B,P},...). The second level contains all orders for a given subset (e.g., [B,I], [I,E]). The third level contains specific   elemnts of the n_way joint probability table. \nattributes::T1: a vector of attribute names\nvalues::T2: a vector of vectors where each sub-vector responses to possible values for a given attribute name\nn_way::Int: the number of attributes defining the n₁ × … × nₘ joint probability table where m=n_way.\n\nwhere T1,T2 <: Vector. \n\nExample output\n\n48×6 DataFrame\n Row │ group  order  attributes  values        val_idx  preds       \n     │ Int64  Int64  Array…      Array…        Int64    Float64     \n─────┼──────────────────────────────────────────────────────────────\n   1 │     1      1  [:B, :I]    [:yes, :yes]        1  0.3\n   2 │     1      1  [:B, :I]    [:no, :yes]         2  0.2\n   3 │     1      1  [:B, :I]    [:yes, :no]         3  0.1\n   4 │     1      1  [:B, :I]    [:no, :no]          4  0.4\n   5 │     1      2  [:I, :B]    [:yes, :yes]        1  0.3\n   6 │     1      2  [:I, :B]    [:yes, :no]         2  0.2\n   7 │     1      2  [:I, :B]    [:no, :yes]         3  0.1\n   8 │     1      2  [:I, :B]    [:no, :no]          4  0.4\n   9 │     2      1  [:B, :P]    [:yes, :yes]        1  0.329624\n  10 │     2      1  [:B, :P]    [:no, :yes]         2  0.624449\n  11 │     2      1  [:B, :P]    [:yes, :no]         3  0.0300594\n  12 │     2      1  [:B, :P]    [:no, :no]          4  0.0158673\n  13 │     2      2  [:P, :B]    [:yes, :yes]        1  0.138197\n  14 │     2      2  [:P, :B]    [:yes, :no]         2  0.392705\n  ⋮\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.to_dataframe-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{Array{Vector{T}, 1}, T1, T2, Int64}} where {T, T1<:(Vector), T2<:(Vector)}","page":"API","title":"QuantumContextEffectModels.to_dataframe","text":"to_dataframe(\n    data::Vector{Vector{Vector{T}}},\n    attributes::T1,\n    values::T2,\n    n_way::Int\n)\n\nFlattens input data into a long form DataFrame. \n\nArguments\n\ndata::Vector{Vector{T}}: a two-level nested data vector of vectors representing data or predictions. Each sub-vector is a different set of    variables comprising the n_way joint probability table. Only one order of a given set of variables included, which is the order    specified in the function make_projectors.\nattributes::T1: a vector of attribute names\nvalues::T2: a vector of vectors where each sub-vector responses to possible values for a given attribute name\nn_way::Int: the number of attributes defining the n₁ × … × nₘ joint probability table where m=n_way.\n\nwhere T1,T2 <: Vector. \n\nOutput\n\n24×4 DataFrame\n Row │ group  attributes  values        preds       \n     │ Int64  Array…      Array…        Float64     \n─────┼──────────────────────────────────────────────\n   1 │     1  [:B, :I]    [:yes, :yes]  0.3\n   2 │     1  [:B, :I]    [:no, :yes]   0.2\n   3 │     1  [:B, :I]    [:yes, :no]   0.1\n   4 │     1  [:B, :I]    [:no, :no]    0.4\n   5 │     2  [:B, :P]    [:yes, :yes]  0.329624\n   6 │     2  [:B, :P]    [:no, :yes]   0.624449\n   7 │     2  [:B, :P]    [:yes, :no]   0.0300594\n   8 │     2  [:B, :P]    [:no, :no]    0.0158673\n   9 │     3  [:B, :L]    [:yes, :yes]  0.333826\n  10 │     3  [:B, :L]    [:no, :yes]   0.599901\n  11 │     3  [:B, :L]    [:yes, :no]   0.0661739\n  12 │     3  [:B, :L]    [:no, :no]    9.88958e-5\n  13 │     4  [:I, :P]    [:yes, :yes]  0.467509\n  14 │     4  [:I, :P]    [:no, :yes]   0.486564\n  15 │     4  [:I, :P]    [:yes, :no]   0.0324905\n  16 │     4  [:I, :P]    [:no, :no]    0.0134361\n  17 │     5  [:I, :L]    [:yes, :yes]  0.322595\n  18 │     5  [:I, :L]    [:no, :yes]   0.611132\n  19 │     5  [:I, :L]    [:yes, :no]   0.0433761\n  20 │     5  [:I, :L]    [:no, :no]    0.0228967\n  21 │     6  [:P, :L]    [:yes, :yes]  0.933579\n  22 │     6  [:P, :L]    [:no, :yes]   0.000148166\n  23 │     6  [:P, :L]    [:yes, :no]   0.0204943\n  24 │     6  [:P, :L]    [:no, :no]    0.0457785\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.to_tables-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{Array{Array{Vector{T}, 1}, 1}, T1, T2, Int64}} where {T, T1, T2}","page":"API","title":"QuantumContextEffectModels.to_tables","text":"to_tables(\n    data::Vector{Vector{Vector{T}}},\n    attributes::T1,\n    values::T2,\n    n_way::Int\n)\n\nReturns a nested vector of DataFrames where each DataFrame is an n₁ × n₂ joint probability table. Each sub-vector of DataFrames contains a DataFrame for each order of a fixed set of attributes. \n\nExample Output\n\nThe example output shows the two joint probability tables for attributes B and I–-one for each order.\n\njulia> df[1]\n2-element Vector{DataFrame}:\n 4×6 DataFrame\n Row │ group  order  attributes  values        val_idx  probs   \n     │ Int64  Int64  Array…      Array…        Int64    Float64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      1  [:B, :I]    [:yes, :yes]        1      0.3\n   2 │     1      1  [:B, :I]    [:no, :yes]         2      0.2\n   3 │     1      1  [:B, :I]    [:yes, :no]         3      0.1\n   4 │     1      1  [:B, :I]    [:no, :no]          4      0.4\n 4×6 DataFrame\n Row │ group  order  attributes  values        val_idx  probs   \n     │ Int64  Int64  Array…      Array…        Int64    Float64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      2  [:I, :B]    [:yes, :yes]        1      0.3\n   2 │     1      2  [:I, :B]    [:yes, :no]         2      0.2\n   3 │     1      2  [:I, :B]    [:no, :yes]         3      0.1\n   4 │     1      2  [:I, :B]    [:no, :no]          4      0.4\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumContextEffectModels.to_tables-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{Array{Vector{T}, 1}, T1, T2, Int64}} where {T, T1, T2}","page":"API","title":"QuantumContextEffectModels.to_tables","text":"to_tables(\n    data::Vector{Vector{Float64}},\n    attributes::T1,\n    values::T2,\n    n_way::Int\n)\n\nReturns a nested vector of DataFrames where each DataFrame is an n₁ × n₂ joint probability table. Each sub-vector of DataFrames contains a DataFrame for each order of a fixed set of attributes. \n\nExample Output\n\njulia> df[1:2]\n2-element Vector{DataFrames.DataFrame}:\n 4×4 DataFrame\n Row │ group  attributes  values        preds   \n     │ Int64  Array…      Array…        Float64 \n─────┼──────────────────────────────────────────\n   1 │     1  [:B, :I]    [:yes, :yes]      0.3\n   2 │     1  [:B, :I]    [:no, :yes]       0.2\n   3 │     1  [:B, :I]    [:yes, :no]       0.1\n   4 │     1  [:B, :I]    [:no, :no]        0.4\n 4×4 DataFrame\n Row │ group  attributes  values        preds     \n     │ Int64  Array…      Array…        Float64   \n─────┼────────────────────────────────────────────\n   1 │     2  [:B, :P]    [:yes, :yes]  0.329624\n   2 │     2  [:B, :P]    [:no, :yes]   0.624449\n   3 │     2  [:B, :P]    [:yes, :no]   0.0300594\n   4 │     2  [:B, :P]    [:no, :no]    0.0158673\n\n\n\n\n\n","category":"method"},{"location":"parameter_estimation/#Parameter-Estimation","page":"Parameter Estimation","title":"Parameter Estimation","text":"","category":"section"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"This brief tutorial explains how to performance Bayesian parameter estimation of the quantum context effect model (QCEM) using Pigeons.jl. One complication in estimating the parameters of the QCEM is that the posterior distributions may have multiple modes, which leads to convergence problems with most MCMC algorithms. Pigeons.jl uses a special type of parallel tempering to overcome this challenge. An additional advantage of using Pigeons.jl is the ability to compute Bayes factors from the log marginal likelihood using the function stepping_stone.","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"<details>\n<summary><b>Show Code</b></summary>","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using QuantumContextEffectModels\nusing Plots \nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\nθlis = range(-1, 1, length=1001)\npreds = map(\n        θli -> predict(\n            QuantumModel(; parms..., θli); \n            joint_func = get_joint_probs,\n            n_way = 2\n        ), θlis)\n\npreds = map(p -> p[5], preds)\n\npreds = stack(preds)'\np1 = plot(θlis[1:500], preds[1:500,:], leg=false, title=\"first half [-1,0)\")\np2 = plot(θlis[1:500], preds[501:end-1,:], leg=false, title=\"second half [0,1)\")\nplot(p1, p2, layout=(2,1))","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"</details>","category":"page"},{"location":"parameter_estimation/#Load-Packages","page":"Parameter Estimation","title":"Load Packages","text":"","category":"section"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"First, we will load the required packages below. ","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Pigeons\nusing QuantumContextEffectModels\nusing Random\nusing StatsPlots\nusing Turing","category":"page"},{"location":"parameter_estimation/#Generate-Simulated-Data","page":"Parameter Estimation","title":"Generate Simulated Data","text":"","category":"section"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The next step is to generate some simulated data from which the parameters can be estimated. In the code block below, the utility parameter mu_d is set to one and the entanglement parameter is set to gamma = 2.  A total of 50 trials is generated for each of the three conditions. The resulting values represent the number of defections per condition out of 50.","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Random.seed!(84)\nn_trials = 25\nn_way = 2\nparms = (\n    Ψ = sqrt.([.7,.1,.1,.1]),\n    θli = .6,\n    θpb = .3,\n)\nmodel = QuantumModel(; parms...)\ndata = rand(model, n_trials; n_way)","category":"page"},{"location":"parameter_estimation/#Define-Turing-Model","page":"Parameter Estimation","title":"Define Turing Model","text":"","category":"section"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The next step is to define a Turing model with the @model macro. We will estimate the entanglement parameters using the prior gamma_j sim mathrmnormal(03). The other parameters will be fixed to the data generating values defined in the code block above.","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"@model function turing_model(data, parms, n_trials; n_way)\n    θli ~ Uniform(0, 1)\n    θpb ~ Uniform(0, 1)\n    model = QuantumModel(; parms..., θli, θpb)\n    Turing.@addlogprob! logpdf(model, data, n_trials; n_way)\nend\n\nsampler = turing_model(data, parms, n_trials; n_way)","category":"page"},{"location":"parameter_estimation/#Estimate-Parameters","page":"Parameter Estimation","title":"Estimate Parameters","text":"","category":"section"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"To estimate the parameters, we need to pass the Turing model to pigeons. The second command converts the output to an MCMCChain object, which can be used for plotting","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"pt = pigeons(\n    target=TuringLogPotential(sampler), \n    record=[traces],\n    multithreaded=true)\nsamples = Chains(sample_array(pt), [\"θli\", \"θbp\", \"LL\"])\nplot(samples)","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"chain = sample(sampler, NUTS(1000, .85), MCMCThreads(), 1000, 4)\nplot(chain)","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The trace of the pigeon's sampler is given below:","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"────────────────────────────────────────────────────────────────────────────\n  scans        Λ      log(Z₁/Z₀)   min(α)     mean(α)    min(αₑ)   mean(αₑ) \n────────── ────────── ────────── ────────── ────────── ────────── ──────────\n        2        4.9       -150          0      0.456      0.857      0.961 \n        4       2.47        402   1.61e-23      0.726      0.973      0.997 \n        8       5.03        444   0.000401      0.441          1          1 \n       16       5.27        459      0.136      0.415      0.993      0.999 \n       32       6.11        461     0.0646      0.321          1          1 \n       64       5.51        466      0.232      0.388          1          1 \n      128       5.13        470      0.257       0.43      0.997          1 \n      256       5.18        469      0.311      0.425      0.998          1 \n      512       5.14        469      0.347      0.429      0.999          1 \n 1.02e+03       5.14        469      0.398      0.429      0.998          1 \n────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"parameter_estimation/#Plot-Posterior-Distribution","page":"Parameter Estimation","title":"Plot Posterior Distribution","text":"","category":"section"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Now we can plot the posterior distribution of gamma with plot. The posterior distribution of gamma has a primary mode around 1 and secondary modes around 2 and 3.5.","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"plot(samples)","category":"page"},{"location":"parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: )","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"warning: Warning\nThis page is under construction.","category":"page"},{"location":"model_description/#Introduction","page":"Model Description","title":"Introduction","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Prior research has found that the judged likelihood of a hypothesis often depends on the order in which evidence is presented. In other words, the final judgment that a hypothesis is true is different for evidence sequence S_i S_j and evidence sequence S_j S_i. The goal of this tutorial is to describe a quantum order effect model (QOEM) as it applies to a medical diagnosis task. The basic model can be adapted to other tasks in which evidence is evaluated sequentially.  ","category":"page"},{"location":"model_description/#Medical-Diagnosis-Task","page":"Model Description","title":"Medical Diagnosis Task","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Medical doctors routinely perform medical diagnosis as part of their job requirements. Medical diagnosis is the process of assessing the probability a patient has a disease based on symptoms and medical tests. Below, we use the QOEM to understand a how a person evaluates the hypothesis that a fictitous patient has a disease (d) after evidence from two informatino sources are presented sequentially. The judgments are made in two conditions, which vary the presentation order of the evidence. In one condition, a person makes the following judgments:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"the probability of disease based on initial symptoms \nupdate the probability of disease after the medical history S_i provides positive evidence for the disease\nupdate the probability of disease after the laboratory test S_j provides negative evidence for the disease","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The procedure for the other condition is identical except the order of the information sources S_iS_j is reversed: ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"the probability of disease based on initial symptoms \nupdate the probability of disease after the laboratory test S_j provides negative evidence for the disease\nupdate the probability of disease after the medical history S_i provides positive evidence for the disease","category":"page"},{"location":"model_description/#Context-Effects","page":"Model Description","title":"Context Effects","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Broadly speaking, a context effect occurs when set of judgments cannot be deduced from a single underlying joint probability distribution. There are several ways this may manifest. One way is a violation of marginal invariance, which occurs when the marginal probability of an event cannot be computed by summing the joint probabilities comprising the event. For example, judgments about four attributes are represented as the following four random variables: V_1 V_2 V_3 V_4 . Suppose subjects judge a subset of two attributes V_1 V_2  from a set of four attributes. Marginal invariance requires that the probability  judgment for attribute 1 is V_1=v_1 and judgment for attribute 2 is V_2=v_2 can be found by marginalizing over the other two judgments V_3V_4, as follows:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Pr(V_1=v_1 cap V_2=v_2) = sum_x_3 in X_3 sum_x_4 in X_4Pr(V_1=v_1 cap V_2=v_2 cap V_3=x_3 cap V_4=x_4)","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"where X_3 and X_4 are all possible values for V_3 and V_4. An order effect occurs when the final probability judgment of disease depends on the order in which evidence is presented. An order effect for two sources of evidence can be stated formally as: ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Pr(V_1 = v_1 cap V_2 = v_2) = Pr(V_2 = v_2 cap V_1 = v_1)","category":"page"},{"location":"model_description/#Quantum-Order-Effect-Model","page":"Model Description","title":"Quantum Order Effect Model","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"According to the QOEM, evidence sources constitute incompatible events, meaning they cannot be considered simultaneously because the joint probability distribution is not defined. In particular, a person cannot represent the 8 dimensional joint distribution of events over disease status (present vs. absent), evidence type (positive vs. negative), and information source (medical history vs. laboratory test). Instead, incompatible events are represented in a lower 4 dimensional space using different bases, which must be evaluated sequentially. Bases correspond to different perspectives of a situation. In the medical diagnosis task, the QOEM assumes that medical history and laboratory tests are viewed one at a time from different perspectives. Order effects arise from this process because the linear algebra operations described below are non-commutative. ","category":"page"},{"location":"model_description/#Basis","page":"Model Description","title":"Basis","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The first step in the process of defining a quantum model is to determine which events are compatible and which are incompatible. The QOEM assumes information source is incompatible, but disease status and evidence type are compatible. Consequentially, the basis of the QOEM consists of four states corresponding to the all possible combinations of disease status and evidence type:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"disease present (p) and positive evidence for disease (p)\ndisease present (p) and negative evidence for disease (n)\ndisease absent (a) and positive evidence for disease (p)\ndisease absent (a) and negative evidence for disease (n)","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"where the values in the parentheses correspond to indices. In the notation used below, the first index corresponds to the presence or absence of the disease, and the second index corresponds to the type of evidence for the disease (positive or negative). Information source is represented as different bases within the reduced 4 dimensional space. Each basis for information source is related to the other bases through a rotation factor, which corresponds to the idea of viewing the diagnosis from different perspectives. More formally, the basis is given by the following orthonormal vectors in the standard position:  ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfB = kettextrmB_ppkettextrmB_pnkettextrmB_apkettextrmB_an","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"where each basis vector consists of a 1 with all other elements equal to zero, e.g., ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"kettextrmB_pp = beginbmatrix\n\t1  \n\t0  \n\t0  \n\t0 \nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Combining the basis vectors into a single matrix, we get the identity matrix:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfI_4 = beginbmatrix\t\t\n\t1  0  0  0\n\t0  1  0  0\n\t0  0  1  0\n\t0  0  0  1\nendbmatrix","category":"page"},{"location":"model_description/#States","page":"Model Description","title":"States","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The state of the cognitive system is a superposition (i.e. linear combination) over basis states:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"ketboldsymbolpsi = alpha_pp ketB_pp + alpha_pn kettextrmB_pn+ alpha_apkettextrmB_ap+ alpha_an kettextrmB_an","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"where lVertketboldsymbolpsi rVert = 1. The coefficients can be written as:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"boldsymbolalpha = beginbmatrix\n\talpha_pp  \n\talpha_pn  \n\talpha_ap  \n\talpha_an  \nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The initial state is is based on the mean probability judgment after the first symptoms are described: ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"ketboldsymbolpsi = beginbmatrix\n\tsqrt(frac6762)  \n\tsqrt(frac6762)  \n\tsqrt(frac3242)  \n\tsqrt(frac3242)  \nendbmatrix","category":"page"},{"location":"model_description/#Projectors","page":"Model Description","title":"Projectors","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The QOEM makes repeated use of three projection matrices. The following projector is used to evaluate the probability of disease:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfP_d = kettextrmB_pp bratextrmB_pp + kettextrmB_pn bratextrmB_pn = beginbmatrix\t\t\n\t1  0  0  0\n\t0  1  0  0\n\t0  0  0  0\n\t0  0  0  0\nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Notice it spans the 2D sub-space in which the disease is present. The next projector is used to evaluate the probability of positive evidence:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfP_p = kettextrmB_pp bratextrmB_pp + kettextrmB_ap bratextrmB_ap = beginbmatrix\t\t\n\t1  0  0  0\n\t0  0  0  0\n\t0  0  1  0\n\t0  0  0  0\nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Similarly, the projector spans the 2D sub-space in which positive evidence is discovered. Finally, the following projector evaluates the probability of negative evidence:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfP_n = kettextrmB_pn bratextrmB_pn + kettextrmB_an bratextrmB_an = beginbmatrix\t\t\n\t0  0  0  0\n\t0  1  0  0\n\t0  0  0  0\n\t0  0  0  1\nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"As before, the projector spans the 2D sub-space in which negative evidence is discovered. ","category":"page"},{"location":"model_description/#Hamiltonian-Matrices","page":"Model Description","title":"Hamiltonian Matrices","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Hamiltonian matrices govern the decision dynamics of the model. The Hamiltonian matrix mathbfH(gamma) consists of two components: mathbfH_1 is sensitive to the payoff matrix, and mathbfH_2 is sensitive to cognitive dissonance between beliefs and actions. The component mathbfH_1 is defined as follows: ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfH_1 = I_2 otimes beginbmatrix\t\t\n\t1  1\n\t1  -1\nendbmatrix = beginbmatrix\t\t\n\t1  1  0  0\n\t1  -1  0  0\n\t0   0  1  1\n\t0  0  1  -1\nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The second component is defined as:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfH_2 = beginbmatrix\t\t\n\t1  0  1  0\n\t0  -1  0  1\n\t1   0  -1  0\n\t0  1  0  1\nendbmatrix","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfH = frac1sqrt2left(mathbfH_1 + mathbfH_2 right)","category":"page"},{"location":"model_description/#Evidence-Evaluation","page":"Model Description","title":"Evidence Evaluation","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"This selection describes the process of selecting an action and determining the defection probability. The time evolution is governed by the unitary transformation matrix which is given by:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfU_h= e^-i cdot t cdot gamma_h cdot mathbfH","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"mathbfU_l = e^-i cdot t cdot  gamma_l cdot mathbfH","category":"page"},{"location":"model_description/#QOEM-Predictions","page":"Model Description","title":"QOEM Predictions","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"In this section, we go through the steps for computing the predictions in the condition in which the medical history is provided followed by the laboratory test. The predictions follow a similar procedure in the condition in which the order of evidence is reversed.","category":"page"},{"location":"model_description/#Assessment-Without-Evidence-Sources","page":"Model Description","title":"Assessment Without Evidence Sources","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"First, we will compute the probability that the disease is present before additional evidence is collected from medical history and laboratory tests. The computation involves projecting the intial state onto the 2D sub-space spanning disease present and squaring the magnitude of the projection, which is computed as:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Pr(D=d) = lVert mathbfP_d ketpsi rVert^2","category":"page"},{"location":"model_description/#Assessment-With-Medical-History","page":"Model Description","title":"Assessment With Medical History","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Next, suppose we update the assessment of the disease given positive evidence from test i is found. The process involves three computations: (1) projecting the initial state onto the positive evidence sub-space, (2) normalizing the state vector, and (3) projecting the new state onto the 2D sub-space spanning disease present. To update the state, we first project onto the sub-space representing medical history.","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"ketpsi_p^prime = mathbfP_p mathbfU_hketpsi","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Note that he unitary matrix mathbfU_p changes the system to the basis for medical history. After projecting on to the 2D sub-space for positive, the state collapses onto that sub-space. As a result, the new state must be normalized such that the squared magnitude is 1:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"ketpsi_p = fracketpsi_p^primelVert ketpsi_p^prime rVert","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The last step involves projecting onto the 2D sub-space spanning disease present and squaring the magnitude to obtain the revised probability judgment for the disease:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Pr(D=d mid S_i = 1) = lVert mathbfP_d ketpsi_p rVert^2","category":"page"},{"location":"model_description/#Assessment-With-Medical-History-and-Laboratory-Test","page":"Model Description","title":"Assessment With Medical History and Laboratory Test","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Next, negative evidence is presented from the laboratory test. A similar sequence of steps is followed. The first step involves projecting onto the 2D sub-space spanned by negative evidence: ","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"ketpsi_pn^prime = mathbfP_n mathbfU_l mathbfU_h^dagger ketpsi_p","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Notice that the process of changing bases involves an extra step. Because the model state is currently in the positive medical history basis, it is necessary to perform the inverse operation with the conjugate transpose mathbfU_h^dagger and then switch to the basis for the laboratory test with mathbfU_l. As before, the state collapses to negative evidence because negative evidence was observed. Thus, the state must be normalized:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"ketpsi_pn = fracketpsi_pn^primelVert ketpsi_pn^prime rVert","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Now that the state is in the sub-space for negative evidence, the last step involves projecting onto the 2D sub-space for disease present to obtain a probability judgment for the presense of the disease:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Pr(D=d mid S_i = 1 S_j=-1) = lVert mathbfP_d ketpsi_pn rVert^2","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Evidence Data Model\n 0.674 0.676\nH 0.778 0.793\nH,L 0.509 0.504\n 0.678 0.676\nL 0.440 0.437\nL,H 0.591 0.590","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The code used to generate the predictions can be viewed by expanding the code block below:","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"<details>\n<summary><b>Show Code</b></summary>","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"using QuantumContextEffectModels\n","category":"page"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"</details>","category":"page"},{"location":"model_description/#Dynamics","page":"Model Description","title":"Dynamics","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The plot below shows the dynamics of the model for each condition.","category":"page"},{"location":"model_description/#Interference-Effects","page":"Model Description","title":"Interference Effects","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"The plot below shows the interference effect as a function of mu for multiple values of gamma. In the simulations below, we fix t=fracpi2.","category":"page"},{"location":"model_description/#References","page":"Model Description","title":"References","text":"","category":"section"},{"location":"model_description/","page":"Model Description","title":"Model Description","text":"Trueblood, J. S., & Busemeyer, J. R. (2011). A quantum probability account of order effects in inference. Cognitive science, 35(8), 1518-1552.","category":"page"},{"location":"basic_usage/#Overview","page":"Basic Usage","title":"Overview","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The purpose of this page is to demonstrate basic usage of the API. The following examples will be based on the context efect model described in Busemeyer & Wang (2018). A brief description of the model can be found here and a more detailed description can be found here.","category":"page"},{"location":"basic_usage/#Make-Predictions","page":"Basic Usage","title":"Make Predictions","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The function predict will generate all possible joint probability tables of a dimensionality specified by n_way. ","category":"page"},{"location":"basic_usage/#Two-way-Tables","page":"Basic Usage","title":"Two-way Tables","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The code block below demonstrates how to generate predictions for 2-way joint probability tables. Each table is of size 2 times 2 because each attribute is binary. Given four attributes and n_way=2, there are P(42) = 12 joint probability tables in total (including the order of attributes within a pair). ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using QuantumContextEffectModels\nn_way = 2\nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\n\nmodel = QuantumModel(; parms...)\npreds = predict(model; n_way)","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The nested vector preds contains C(42) = 6 combinations of attributes (ignoring order). As shown below, each sub-vector contains a flattened joint probability table, one for each order. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"preds[1]","category":"page"},{"location":"basic_usage/#Three-way-Tables","page":"Basic Usage","title":"Three-way Tables","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The code block below shows how to create all possible joint probability tables of dimensionality 3 by changing n_way=2 to n_way=3. In this example,there are P(43) = 24 joint probability tables (6 orders for each unique set of 3 attributes). ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"preds = predict(model; n_way = 3)","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"In general, if there are n_a attributes, the function predict can generate tables of dimensionality 12dots n_a.","category":"page"},{"location":"basic_usage/#Single-Order","page":"Basic Usage","title":"Single Order","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"As shown below, you can assign the function get_joint_probs to the keyword joint_func to omit the orders of joint probability tables (e.g., [A,B] instead of [A,B], [B,A]). ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using QuantumContextEffectModels\nn_way = 2\nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\n\nmodel = QuantumModel(; parms...)\npreds = predict(\n    model;\n    joint_func = get_joint_probs, \n    n_way\n)","category":"page"},{"location":"basic_usage/#Simulate-Model","page":"Basic Usage","title":"Simulate Model","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The code block below demonstrates how to generate simulated data from the model using rand. In the example, we will generate 100 simulated trials for each condition. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using QuantumContextEffectModels\nn_way = 2\nn_trials = 100\nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\n\nmodel = QuantumModel(; parms...)\ndata = rand(model, n_trials; n_way)","category":"page"},{"location":"basic_usage/#Labeled-Tables","page":"Basic Usage","title":"Labeled Tables","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Interpreting the large number of nested arrays can be challenging. In the model illustrated here, there are 12 two-way tables embedded within the nested arrays. We can use to_table to assign labels to aid in the intepretation. In the code block below, we define two variables: var_names, which is the name of the attributes, and values which are the corresponding values for each attribute. To ensure the tables are labeled correctly, it is necessary to use the same order of attributes and values defined in make_projectors. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"There are 12 tables in the full set. For ease of presentation, we will focus on the first two sets. The first set contains two tables for attributes believable and informative–-one for each order. The predictions are the same for each order because believable and informative are compatible. For example, ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Pr(B = -1 cap I = 1) = Pr(I = 1 cap B = -1) = 20","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"where 1 corresponds to yes and -1 correspond to no. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using QuantumContextEffectModels\nn_way = 2\nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\n\nmodel = QuantumModel(; parms...)\npreds = predict(model; n_way)\n\nvar_names = [\n    :B, # believable\n    :I, # informative\n    :P, # persuasive\n    :L  # likable\n]\nvalues = fill([:yes,:no], 4)\n\ndf = to_tables(preds, var_names, values, n_way)\ndf[1]","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The code block below shows the second set for believable and persuasive. Again, there is a 2 times 2 table for each order. However, in this case, the 2 times 2 tables are different because believable and persuasive are incompatible, resulting in order effects. For example, ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Pr(B = -1 cap P = 1) ne Pr(P = 1 cap B = -1)","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"df[2]","category":"page"},{"location":"basic_usage/#DataFrame","page":"Basic Usage","title":"DataFrame","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"In many cases, the use of a flat data structure can facilitate data analysis and plotting. The function to_dataframe converts a nested array into a flat DataFrame object. Similar to the function to_tables, to_dataframe requires attribute names and attribute values, which are specified in the same order as the projectors in make_projectors. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using QuantumContextEffectModels\nn_way = 2\nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\n\nmodel = QuantumModel(; parms...)\npreds = predict(model; n_way)\n\nvar_names = [\n    :B, # believable\n    :I, # informative\n    :P, # persuasive\n    :L  # likable\n]\nvalues = fill([:yes,:no], 4)\n\ndf = to_dataframe(preds, var_names, values, n_way)\nfirst(df, 8)","category":"page"},{"location":"basic_usage/#Evaluate-Log-Likelihood","page":"Basic Usage","title":"Evaluate Log Likelihood","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The log likelihood of data can be evaluated using logpdf. In the code block below, we generate simulated data and evaluate the logpdf: ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using QuantumContextEffectModels\nn_way = 2\nn_trials = 100\nparms = (\n    Ψ = sqrt.([.3,.1,.2,.4]),\n    θli = .3,\n    θpb = .3,\n)\n\nmodel = QuantumModel(; parms...)\ndata = rand(model, n_trials; n_way)\nlogpdf(model, data, n_trials; n_way)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nDocumentation is under construction","category":"page"},{"location":"#QuantumContextEffectModels.jl","page":"Home","title":"QuantumContextEffectModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a framework for creating quantum models of context effects.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two methods for installing the package. Option 1 is to install without version control. In the REPL, use ] to switch to the package mode and enter the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/itsdfish/QuantumContextEffectModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Option 2 is to install via a custom registry. The advantage of this approach is greater version control through Julia's package management system. This entails two simple steps. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install the registry using the directions found here.\nAdd the package by typing ] into the REPL and then typing (or pasting):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add QuantumContextEffectModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"I recommend adding the package to a project-specific environment and specifying version constraints in the Project.toml to ensure reproducibility. For an example, see the Project.toml file associated with this package.  ","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Busemeyer, J. R., & Wang, Z. (2018). Hilbert space multidimensional theory. Psychological Review, 125(4), 572.","category":"page"}]
}
